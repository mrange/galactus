<#@ assembly    name        ="System.Core"                  #>
<#@ assembly    name        ="WindowsBase"                  #>
<#@ assembly    name        ="PresentationCore"             #>
<#@ assembly    name        ="PresentationFramework"        #>

<#@ import      namespace   ="System"                       #>
<#@ import      namespace   ="System.Text"                  #>
<#@ import      namespace   ="System.Collections.Generic"   #>
<#@ import      namespace   ="System.Linq"                  #>
<#@ import      namespace   ="System.Reflection"            #>

namespace Galactus.Standard
{
  using Galactus.Core;

<#
  string FixName(string s)
  {
    var name = s.Length > 0
      ? (Char.IsLower(s[0]) ? s : (Char.ToLowerInvariant(s[0])).ToString () + s.Substring(1))
      : s;

    switch (name)
    {
    case "checked":
    case "unchecked":
      return name + "_";
    default:
      return name;
    }
  }

  string RemoveTrailing(string t, string s)
  {
    var i = s.LastIndexOf(t);
    return i > 0
      ? s.Substring(0, i)
      : s
      ;
  }

  string TypeName(Type t)
  {
    var sb = new StringBuilder(16);

    void Loop(Type tp)
    {
      if (tp.IsGenericType)
      {
        var itps  = tp.GetGenericArguments();
        var gtp   = tp.GetGenericTypeDefinition();
        var tpn   = RemoveTrailing("`" + itps.Length, gtp.FullName);
        sb
          .Append(tpn)
          .Append('<')
          ;
        for (var i = 0; i < itps.Length; ++i)
        {
          if (i > 0) sb.Append(", ");
          Loop(itps[i]);
        }
        sb
          .Append('>')
          ;
      }
      else
      {
        sb.Append(tp.FullName);
      }
    }

    Loop(t);

    return sb.ToString();
  }

  var content             = typeof (System.Windows.Controls.ContentControl)   ;
  var decorator           = typeof (System.Windows.Controls.Decorator)        ;
  var dependencyProperty  = typeof (System.Windows.DependencyProperty)        ;
  var routedEvent         = typeof (System.Windows.RoutedEvent)               ;
  var eventArgs           = typeof (System.EventArgs)                         ;
  var panel               = typeof (System.Windows.Controls.Panel)            ;
  var uiElement           = typeof (System.Windows.UIElement)                 ;

  var assemblies = new [] {
      uiElement.Assembly
    , panel.Assembly
  };

  var blackList = new HashSet<Type> (new Type[] {
//      typeof (System.Windows.Interop.HwndHost)
  });

  var types = assemblies
    .SelectMany(a => a.ExportedTypes)
    .Where(t => t == uiElement || t.IsSubclassOf(uiElement))
    .Where(t => !t.IsGenericType)
    .Where(t => !blackList.Contains(t))
    .OrderBy(t => t.Name)
    ;
#>

  public static partial class Properties
  {
<#
  foreach (var tp in types)
  {
    var bt    = tp.BaseType;
    var bfs   = BindingFlags.DeclaredOnly | BindingFlags.Public;

    var dps   = tp
      .GetFields(BindingFlags.Static | bfs)
      .Where(f => f.Name.EndsWith("Property") && f.FieldType == dependencyProperty)
      .ToArray()
      ;

  var etn = TypeName(tp);
  var etsn= FixName(tp.Name);
#>
    public partial class <#=etsn#><#= tp == uiElement ? "" : " : " + FixName(bt.Name) #>
    {
<#
  foreach (var f in dps)
  {
    var dp    = (System.Windows.DependencyProperty)f.GetValue(null);
    var pn    = FixName(RemoveTrailing("Property", f.Name));
    var dptn  = TypeName(dp.PropertyType);
#>
      public static readonly IProperty<<#=etn#>, <#=dptn#>> <#=pn#> = new Property<<#=etn#>, <#=dptn#>>(<#=etn#>.<#=f.Name#>);
<#
  }
#>
    }

<#
  }
#>
  }

  public static partial class Events
  {
<#
  foreach (var tp in types)
  {
    var bt    = tp.BaseType;
    var bfs   = BindingFlags.DeclaredOnly | BindingFlags.Public;

    var evts  = tp
      .GetFields(BindingFlags.Static | bfs)
      .Where(f => f.Name.EndsWith("Event") && f.FieldType == routedEvent)
      .ToArray()
      ;

  var etn = TypeName(tp);
  var etsn= FixName(tp.Name);
#>
    public partial class <#=etsn#><#= tp == uiElement ? "" : " : " + FixName(bt.Name) #>
    {
<#
  foreach (var f in evts)
  {
    var e     = (System.Windows.RoutedEvent)f.GetValue(null);
    var en    = FixName(RemoveTrailing("Event", f.Name))    ;
    var eht   = e.HandlerType                               ;
    var mi    = eht.GetMethod("Invoke")                     ;
    var ps    = mi.GetParameters()                          ;
    var p     = ps[1]                                       ;
    var eat   = p.ParameterType                             ;
    var ehn   = TypeName(eht)                               ;
    var ean   = TypeName(eat)                               ;
#>
      public static readonly IEvent<<#=etn#>, <#=ehn#>, <#=ean#>> <#=en#> = new Event<<#=etn#>, <#=ehn#>, <#=ean#>>(<#=etn#>.<#=f.Name#>);
<#
  }
#>
    }

<#
  }
#>
  }

  public static partial class Controls<TMessage>
  {
<#
  foreach (var tp in types)
  {
    var bt    = tp.BaseType;
    var bfs   = BindingFlags.DeclaredOnly | BindingFlags.Public;

    var dps   = tp
      .GetFields(BindingFlags.Static | bfs)
      .Where(f => f.Name.EndsWith("Property") && f.FieldType == dependencyProperty)
      .ToArray()
      ;

    var evts  = tp
      .GetFields(BindingFlags.Static | bfs)
      .Where(f => f.Name.EndsWith("Event") && f.FieldType == routedEvent)
      .ToArray()
      ;

  var etn = TypeName(tp);
  var etsn= FixName(tp.Name);
#>
    public partial class <#=etsn#><#= tp == uiElement ? "" : " : " + FixName(bt.Name) #>
    {
<#
  foreach (var f in dps)
  {
    var dp    = (System.Windows.DependencyProperty)f.GetValue(null);
    var pn    = FixName(RemoveTrailing("Property", f.Name));
    var dptn  = TypeName(dp.PropertyType);
#>
      public static IValue<TMessage, <#=etn#>> <#=pn#>(<#=dptn#> v) => new SetValue<TMessage, <#=etn#>, <#=dptn#>>(Properties.<#=etsn#>.<#=pn#>, v);
<#
  }
#>

<#
  foreach (var f in evts)
  {
    var e     = (System.Windows.RoutedEvent)f.GetValue(null);
    var en    = FixName(RemoveTrailing("Event", f.Name))    ;
    var eht   = e.HandlerType                               ;
    var mi    = eht.GetMethod("Invoke")                     ;
    var ps    = mi.GetParameters()                          ;
    var p     = ps[1]                                       ;
    var eat   = p.ParameterType                             ;
    var ehn   = TypeName(eht)                               ;
    var ean   = TypeName(eat)                               ;
    // TODO: Handle the case when ehn = EventHandler<TEventArgs>
#>
      public static IValue<TMessage, <#=etn#>> on<#=RemoveTrailing("Event", f.Name)#> (OnChange<TMessage, <#=etn#>, <#=ean#>> onChange) =>
        new OnChangedValue<TMessage, <#=etn#>, <#=ehn#>, <#=ean#>> (Events.<#=etsn#>.<#=en#>, h => (<#=ehn#>)h.Invoke, onChange);
<#
  }
#>

<#
  if (!tp.IsAbstract && tp.GetConstructor(new Type [] {}) != null)
  {
  if (tp.IsSubclassOf(content))
  {
#>
      public static DelayedContentView<TMessage> View(params IValue<TMessage, <#=etn#>>[] vs) => c => new StandardContentView<TMessage, <#=etn#>>(vs, c);
<#
  }
  else if (tp.IsSubclassOf(decorator))
  {
#>
      public static DelayedDecoratorView<TMessage> View(params IValue<TMessage, <#=etn#>>[] vs) => c => new StandardDecoratorView<TMessage, <#=etn#>>(vs, c);
<#
  }
  else if (tp.IsSubclassOf(panel))
  {
#>
      public static DelayedPanelView<TMessage> View(params IValue<TMessage, <#=etn#>>[] vs) => cs => new StandardPanelView<TMessage, <#=etn#>>(vs, cs);
<#
  }
  else
  {
#>
      public static IView<TMessage> View(params IValue<TMessage, <#=etn#>>[] vs) => new StandardView<TMessage, <#=etn#>>(vs);
<#
  }
  }
#>
    }

<#
  }
#>
  }
}
