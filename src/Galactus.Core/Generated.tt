<#@ assembly    name        ="System.Core"                  #>
<#@ assembly    name        ="WindowsBase"                  #>
<#@ assembly    name        ="PresentationCore"             #>
<#@ assembly    name        ="PresentationFramework"        #>

<#@ import      namespace   ="System"                       #>
<#@ import      namespace   ="System.Text"                  #>
<#@ import      namespace   ="System.Collections.Generic"   #>
<#@ import      namespace   ="System.Linq"                  #>
<#@ import      namespace   ="System.Reflection"            #>

#pragma warning disable CS0108
namespace Galactus.Standard
{
  using Galactus.Core;

<#
  bool IsSubclassOfOrEqual(Type l, Type r)
  {
    return l == r || l.IsSubclassOf(r);
  }

  Type GetParameterType(MethodInfo mi, int i)
  {
    if (mi != null)
    {
      return mi.GetParameters()[i].ParameterType;
    }
    else
    {
      return null;
    }
  }

  string FixName(string s)
  {
    var name = s.Length > 0
      ? (Char.IsLower(s[0]) ? s : (Char.ToLowerInvariant(s[0])).ToString () + s.Substring(1))
      : s;

    switch (name)
    {
    case "checked":
    case "unchecked":
      return name + "_";
    default:
      return name;
    }
  }

  string RemoveTrailing(string t, string s)
  {
    var i = s.LastIndexOf(t);
    return i > 0
      ? s.Substring(0, i)
      : s
      ;
  }

  string TypeName(Type t)
  {
    var sb = new StringBuilder(16);

    void Loop(Type tp)
    {
      if (tp.IsGenericType)
      {
        var itps  = tp.GetGenericArguments();
        var gtp   = tp.GetGenericTypeDefinition();
        var tpn   = RemoveTrailing("`" + itps.Length, gtp.FullName);
        sb
          .Append(tpn)
          .Append('<')
          ;
        for (var i = 0; i < itps.Length; ++i)
        {
          if (i > 0) sb.Append(", ");
          Loop(itps[i]);
        }
        sb
          .Append('>')
          ;
      }
      else
      {
        sb.Append(tp.FullName);
      }
    }

    Loop(t);

    return sb.ToString();
  }

  var dependencyObject    = typeof (System.Windows.DependencyObject)                ;
  var content             = typeof (System.Windows.Controls.ContentControl)         ;
  var decorator           = typeof (System.Windows.Controls.Decorator)              ;
  var dependencyProperty  = typeof (System.Windows.DependencyProperty)              ;
  var eventArgs           = typeof (System.EventArgs)                               ;
  var headeredContent     = typeof (System.Windows.Controls.HeaderedContentControl) ;
  var panel               = typeof (System.Windows.Controls.Panel)                  ;
  var routedEvent         = typeof (System.Windows.RoutedEvent)                     ;
  var uiElement           = typeof (System.Windows.UIElement)                       ;

  Type MinUIElement(Type t)
  {
    if (t.IsSubclassOf(uiElement))
    {
      return t;
    }
    else
    {
      return uiElement;
    }
  }

  var assemblies = new [] {
      uiElement.Assembly
    , panel.Assembly
  };

  var blackList = new HashSet<Type> (new Type[] {
//      typeof (System.Windows.Interop.HwndHost)
  });

  var types = assemblies
    .SelectMany(a => a.ExportedTypes)
    .Where(t => IsSubclassOfOrEqual(t, uiElement))
    .Where(t => !t.IsGenericType)
    .Where(t => !blackList.Contains(t))
    .OrderBy(t => t.Name)
    ;
#>

  public static partial class Properties
  {
<#
  foreach (var tp in types)
  {
    var bt    = tp.BaseType;
    var bfs   = BindingFlags.DeclaredOnly | BindingFlags.Public;

    var dps   = tp
      .GetFields(BindingFlags.Static | bfs)
      .Where(f => f.Name.EndsWith("Property") && f.FieldType == dependencyProperty)
      .ToArray()
      ;

  var etn = TypeName(tp);
  var etsn= FixName(tp.Name);
#>
    public partial class <#=etsn#><#= tp == uiElement ? "" : " : " + FixName(bt.Name) #>
    {
<#
  foreach (var f in dps)
  {
    var dp    = (System.Windows.DependencyProperty)f.GetValue(null);
    var dpr   = dp.ReadOnly;
    var dpn   = RemoveTrailing("Property", f.Name);
    var dpas  = tp.GetMethod("Set" + dpn, BindingFlags.Static | BindingFlags.Public);
    var dpasto= GetParameterType(dpas, 0);
    var dpast = GetParameterType(dpas, 1);
    var pn    = FixName(dpn);
    var dpt   = dp.PropertyType;
    var dptn  = TypeName(dpt);
    var tn    = dpas != null && IsSubclassOfOrEqual(dpasto, dependencyObject) && dpast == dpt
      ? TypeName(MinUIElement(dpasto))
      : etn
      ;
    if (!dpr)
    {
#>
      public static readonly IProperty<<#=tn#>, <#=dptn#>> <#=pn#> = new Property<<#=tn#>, <#=dptn#>>(<#=etn#>.<#=f.Name#>);
<#
    }
  }
#>
    }

<#
  }
#>
  }

  public static partial class Events
  {
<#
  foreach (var tp in types)
  {
    var bt    = tp.BaseType;
    var bfs   = BindingFlags.DeclaredOnly | BindingFlags.Public;

    var evts  = tp
      .GetFields(BindingFlags.Static | bfs)
      .Where(f => f.Name.EndsWith("Event") && f.FieldType == routedEvent)
      .ToArray()
      ;

  var etn = TypeName(tp);
  var etsn= FixName(tp.Name);
#>
    public partial class <#=etsn#><#= tp == uiElement ? "" : " : " + FixName(bt.Name) #>
    {
<#
  foreach (var f in evts)
  {
    var e     = (System.Windows.RoutedEvent)f.GetValue(null);
    var en    = FixName(RemoveTrailing("Event", f.Name))    ;
    var ers   = e.RoutingStrategy                           ;
    var eht   = e.HandlerType                               ;
    var mi    = eht.GetMethod("Invoke")                     ;
    var ps    = mi.GetParameters()                          ;
    var p     = ps[1]                                       ;
    var eat   = p.ParameterType                             ;
    var ehn   = TypeName(eht)                               ;
    var ean   = TypeName(eat)                               ;
    // TODO: Specialized direct/non-direct events
    var tn    = ers == System.Windows.RoutingStrategy.Direct
      ? etn
      : "System.Windows.UIElement"
      ;
#>
      public static readonly IEvent<<#=tn#>, <#=ehn#>, <#=ean#>> <#=en#> = new Event<<#=tn#>, <#=ehn#>, <#=ean#>>(<#=etn#>.<#=f.Name#>);
<#
  }
#>
    }

<#
  }
#>
  }

  public static partial class Controls<TMessage>
  {
<#
  foreach (var tp in types)
  {
    var bt    = tp.BaseType;
    var bfs   = BindingFlags.DeclaredOnly | BindingFlags.Public;

    var dps   = tp
      .GetFields(BindingFlags.Static | bfs)
      .Where(f => f.Name.EndsWith("Property") && f.FieldType == dependencyProperty)
      .ToArray()
      ;

    var evts  = tp
      .GetFields(BindingFlags.Static | bfs)
      .Where(f => f.Name.EndsWith("Event") && f.FieldType == routedEvent)
      .ToArray()
      ;

  var etn = TypeName(tp);
  var etsn= FixName(tp.Name);
#>
    public partial class <#=etsn#><#= tp == uiElement ? "" : " : " + FixName(bt.Name) #>
    {
<#
  foreach (var f in dps)
  {
    var dp    = (System.Windows.DependencyProperty)f.GetValue(null);
    var dpr   = dp.ReadOnly;
    var dpn   = RemoveTrailing("Property", f.Name);
    var dpas  = tp.GetMethod("Set" + dpn, BindingFlags.Static | BindingFlags.Public);
    var dpasto= GetParameterType(dpas, 0);
    var dpast = GetParameterType(dpas, 1);
    var pn    = FixName(dpn);
    var dpt   = dp.PropertyType;
    var dptn  = TypeName(dpt);
    var tn    = dpas != null && IsSubclassOfOrEqual(dpasto, dependencyObject) && dpast == dpt
      ? TypeName(MinUIElement(dpasto))
      : etn
      ;
    if (!dpr)
    {
#>
      public static ISetValue<TMessage, <#=tn#>, <#=dptn#>> <#=pn#>(<#=dptn#> v) => new SetValue<TMessage, <#=tn#>, <#=dptn#>>(Properties.<#=etsn#>.<#=pn#>, v);
<#
    }
  }
#>

<#
  foreach (var f in evts)
  {
    var e     = (System.Windows.RoutedEvent)f.GetValue(null);
    var en    = FixName(RemoveTrailing("Event", f.Name))    ;
    var ers   = e.RoutingStrategy                           ;
    var eht   = e.HandlerType                               ;
    var mi    = eht.GetMethod("Invoke")                     ;
    var ps    = mi.GetParameters()                          ;
    var p     = ps[1]                                       ;
    var eat   = p.ParameterType                             ;
    var ehn   = TypeName(eht)                               ;
    var ean   = TypeName(eat)                               ;
    // TODO: Specialized direct/non-direct events
    var tn    = ers == System.Windows.RoutingStrategy.Direct
      ? etn
      : "System.Windows.UIElement"
      ;
    // TODO: Handle the case when ehn = EventHandler<TEventArgs>
#>
      public static IOnChangedValue<TMessage, <#=tn#>, <#=ehn#>, <#=ean#>> on<#=RemoveTrailing("Event", f.Name)#> (OnChange<TMessage, <#=tn#>, <#=ean#>> onChange) =>
        new OnChangedValue<TMessage, <#=tn#>, <#=ehn#>, <#=ean#>> (Events.<#=etsn#>.<#=en#>, h => (<#=ehn#>)h.Invoke, onChange);
<#
  }
#>

<#
  if (!tp.IsAbstract && tp.GetConstructor(new Type [] {}) != null)
  {
#>
      public static IView<TMessage> View(params IValue<TMessage, <#=etn#>>[] vs) => new StandardView<TMessage, <#=etn#>>(vs);
<#
  }
#>
    }

<#
  }
#>
  }
}
#pragma warning restore CS0108
